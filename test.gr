module Test

from "string" include String
from "stack" include Stack
from "map" include Map
from "option" include Option
from "buffer" include Buffer

provide record TestDefinition {
    name: String,
    assertions: Stack.Stack<() => Option<String>>
}

let tests = Map.make();

provide let def = (name, callback) => { 
    let state = {
        name: name,
        assertions: Stack.make()
    }

    callback(state)

    Map.set(name, state, tests)
}

let runSingleTest = (definition) => { 
    let wasSuccessfull = box(true)
    let errorBuffer = Buffer.make(5)
    let testName = definition.name

    while(!Stack.isEmpty(definition.assertions)) {
        let assertion = Option.unwrap(Stack.pop(definition.assertions))

        let result = assertion()

        if(Option.isSome(result)) {
            let error = Option.unwrap(result)

            print(testName ++ " failed:")
            Buffer.addString("\t" ++ error ++ "\n", errorBuffer)
        }
        else {
            wasSuccessfull := false
        }
    }

    if(unbox(wasSuccessfull)) {
        print(testName ++ " successfull")
    }
    else {
        print(Buffer.toString(errorBuffer))
    }
}

provide let run = (testName) => {
    match(Map.get(testName, tests)) {
        Some(definition) => runSingleTest(definition),
        None => print(testName ++ " not found")
    }
}

provide let runAll = () => {
    Map.forEach((key, value) => runSingleTest(value), tests)
}

let pushAssertion = (state, toCheck, message) => {
    let check = () => {
        if(toCheck) {
            None()
        }
        else {
            Some(message)
        }
    }

    Stack.push(check, state.assertions)
}

provide let assertEq = (state, expected, actual) => {
    pushAssertion(state, expected == actual,
        "expected " ++ toString(expected) ++ " but got " ++ toString(actual))
}
